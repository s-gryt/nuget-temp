import * as vscode from 'vscode';
import {
  IVulnerabilityScanner,
  VulnerabilityScanResult,
  NuGetPackage,
  VulnerabilityCount,
  CommandExecutionOptions,
  VulnerabilityInfo
} from '../types/dependency';
import { DotNetCliService } from './dotnetCliService';
import { CacheManager } from './cacheManager';

export class VulnerabilityScanner implements IVulnerabilityScanner {
  private cliService: DotNetCliService;
  private cacheManager: CacheManager;
  private readonly vulnerabilityCacheTtl = 30 * 60 * 1000; // 30 minutes
  private readonly offlineCacheTtl = 24 * 60 * 60 * 1000; // 24 hours for offline mode

  constructor(context: vscode.ExtensionContext, cacheManager?: CacheManager) {
    this.cliService = new DotNetCliService();
    this.cacheManager = cacheManager || new CacheManager(context);
  }

  async scanProject(projectPath: string, options: CommandExecutionOptions = {}): Promise<VulnerabilityScanResult> {
    try {
      // First, check if we have valid cached vulnerability data
      const cachedVulnerabilities = await this.cacheManager.getCachedVulnerabilityData(projectPath);
      if (cachedVulnerabilities) {
        return this.createResultFromVulnerabilities(cachedVulnerabilities, 'cache');
      }

      // Try to get fresh results from CLI
      const isCliAvailable = await this.cliService.isAvailable();

      if (isCliAvailable) {
        try {
          const cliOptions: CommandExecutionOptions = {
            timeout: options.timeout || 60000, // 60 seconds timeout
            ...(options.cwd && { cwd: options.cwd })
          };

          const packages = await this.cliService.listVulnerablePackages(projectPath, cliOptions);

          // Extract vulnerability data for persistent caching
          const vulnerabilities = this.extractVulnerabilities(packages);

          // Cache vulnerability data persistently
          await this.cacheManager.cacheVulnerabilityData(projectPath, vulnerabilities);

          const vulnerabilityCount = this.countVulnerabilities(packages);

          const result: VulnerabilityScanResult = {
            packages,
            vulnerabilityCount,
            scanTimestamp: new Date(),
            source: 'dotnet-cli'
          };

          // Also cache the full result in memory for quick access
          const cacheKey = this.getCacheKey(projectPath);
          await this.cacheManager.set(cacheKey, result, this.vulnerabilityCacheTtl);

          return result;
        } catch (cliError) {
          // If CLI scan fails, try to return any cached results (even expired)
          const fallbackResult = await this.getFallbackCachedResults(projectPath);
          if (fallbackResult) {
            return {
              ...fallbackResult,
              source: 'cache',
              error: `CLI scan failed, using cached data: ${cliError}`
            };
          }

          // If no cache available, return empty result with error info
          return this.createEmptyResult('dotnet-cli', `CLI scan failed: ${cliError}`);
        }
      } else {
        // CLI not available, try any cached results
        const fallbackResult = await this.getFallbackCachedResults(projectPath);
        if (fallbackResult) {
          return {
            ...fallbackResult,
            source: 'cache',
            error: '.NET CLI not available, using cached data'
          };
        }

        // No CLI and no cache, return empty result
        return this.createEmptyResult('cache', '.NET CLI not available and no cached results found');
      }
    } catch (error) {
      // Last resort: try any cached results
      const fallbackResult = await this.getFallbackCachedResults(projectPath);
      if (fallbackResult) {
        return {
          ...fallbackResult,
          source: 'cache',
          error: `Vulnerability scan failed, using cached data: ${error}`
        };
      }

      throw new Error(`Failed to scan project for vulnerabilities: ${error}`);
    }
  }

  async getCachedResults(projectPath: string): Promise<VulnerabilityScanResult | null> {
    const cacheKey = this.getCacheKey(projectPath);
    return await this.cacheManager.get<VulnerabilityScanResult>(cacheKey);
  }

  async clearCache(projectPath: string): Promise<void> {
    const cacheKey = this.getCacheKey(projectPath);
    await this.cacheManager.delete(cacheKey);
  }

  /**
   * Scan project with offline support - uses longer cache TTL
   */
  async scanProjectOffline(projectPath: string): Promise<VulnerabilityScanResult> {
    const cacheKey = this.getCacheKey(projectPath);

    // First check if we have any cached results (even if expired for online use)
    const cachedResult = await this.cacheManager.get<VulnerabilityScanResult>(cacheKey);

    if (cachedResult) {
      // Check if cache is still valid for offline use (longer TTL)
      const now = new Date().getTime();
      const cacheTime = cachedResult.scanTimestamp.getTime();

      if (now - cacheTime <= this.offlineCacheTtl) {
        return {
          ...cachedResult,
          source: 'cache'
        };
      }
    }

    // Try to get fresh results if possible
    try {
      const freshResult = await this.scanProject(projectPath);
      return freshResult;
    } catch (error) {
      // If fresh scan fails but we have cached results, use them
      if (cachedResult) {
        return {
          ...cachedResult,
          source: 'cache'
        };
      }

      throw new Error(`Offline vulnerability scan failed and no cached results available: ${error}`);
    }
  }

  /**
   * Get vulnerability statistics for a project
   */
  async getVulnerabilityStats(projectPath: string): Promise<VulnerabilityCount> {
    try {
      const result = await this.scanProject(projectPath);
      return result.vulnerabilityCount;
    } catch (error) {
      return { critical: 0, high: 0, moderate: 0, low: 0, total: 0 };
    }
  }

  /**
   * Check if vulnerability data is available (cached or fresh)
   */
  async hasVulnerabilityData(projectPath: string): Promise<boolean> {
    const cachedResult = await this.getCachedResults(projectPath);
    if (cachedResult) {
      return true;
    }

    try {
      const isCliAvailable = await this.cliService.isAvailable();
      return isCliAvailable;
    } catch {
      return false;
    }
  }

  /**
   * Force refresh vulnerability data (bypass cache)
   */
  async refreshVulnerabilityData(
    projectPath: string,
    options: CommandExecutionOptions = {}
  ): Promise<VulnerabilityScanResult> {
    // Clear existing cache
    await this.clearCache(projectPath);

    // Perform fresh scan
    return await this.scanProject(projectPath, options);
  }

  private getCacheKey(projectPath: string): string {
    // Normalize path for consistent caching
    const normalizedPath = projectPath.replace(/\\/g, '/');
    return `vulnerability-scan:${normalizedPath}`;
  }

  private createEmptyResult(
    source: 'dotnet-cli' | 'nuget-api' | 'cache',
    errorMessage?: string
  ): VulnerabilityScanResult {
    return {
      packages: [],
      vulnerabilityCount: { critical: 0, high: 0, moderate: 0, low: 0, total: 0 },
      scanTimestamp: new Date(),
      source,
      ...(errorMessage && { error: errorMessage })
    };
  }

  private countVulnerabilities(packages: NuGetPackage[]): VulnerabilityCount {
    const count = { critical: 0, high: 0, moderate: 0, low: 0, total: 0 };

    packages.forEach(pkg => {
      if (pkg.vulnerabilities) {
        pkg.vulnerabilities.forEach(vuln => {
          switch (vuln.severity.toLowerCase()) {
            case 'critical':
              count.critical++;
              break;
            case 'high':
              count.high++;
              break;
            case 'moderate':
              count.moderate++;
              break;
            case 'low':
              count.low++;
              break;
          }
          count.total++;
        });
      }
    });

    return count;
  }

  /**
   * Extract vulnerability information from packages for persistent caching
   */
  private extractVulnerabilities(packages: NuGetPackage[]): VulnerabilityInfo[] {
    const vulnerabilities: VulnerabilityInfo[] = [];

    packages.forEach(pkg => {
      if (pkg.vulnerabilities) {
        pkg.vulnerabilities.forEach(vuln => {
          vulnerabilities.push({
            packageName: pkg.id,
            packageVersion: pkg.version,
            severity: vuln.severity,
            title: vuln.title,
            description: vuln.description || '',
            advisoryUrl: vuln.advisoryUrl || ''
          });
        });
      }
    });

    return vulnerabilities;
  }

  /**
   * Create vulnerability scan result from cached vulnerability data
   */
  private createResultFromVulnerabilities(
    vulnerabilities: VulnerabilityInfo[],
    source: 'cache'
  ): VulnerabilityScanResult {
    // Group vulnerabilities by package
    const packageMap = new Map<string, NuGetPackage>();

    vulnerabilities.forEach(vuln => {
      const packageKey = `${vuln.packageName}@${vuln.packageVersion}`;

      if (!packageMap.has(packageKey)) {
        packageMap.set(packageKey, {
          id: vuln.packageName,
          version: vuln.packageVersion,
          vulnerabilities: []
        });
      }

      const pkg = packageMap.get(packageKey);
      if (pkg && pkg.vulnerabilities) {
        pkg.vulnerabilities.push({
          id: '',
          severity: vuln.severity as 'Low' | 'Moderate' | 'High' | 'Critical',
          title: vuln.title,
          description: vuln.description || undefined,
          advisoryUrl: vuln.advisoryUrl || undefined
        });
      }
    });

    const packages = Array.from(packageMap.values());
    const vulnerabilityCount = this.countVulnerabilities(packages);

    return {
      packages,
      vulnerabilityCount,
      scanTimestamp: new Date(),
      source
    };
  }

  /**
   * Get fallback cached results (including expired cache for offline scenarios)
   */
  private async getFallbackCachedResults(projectPath: string): Promise<VulnerabilityScanResult | null> {
    // First try in-memory cache
    const memoryResult = await this.getCachedResults(projectPath);
    if (memoryResult) {
      return memoryResult;
    }

    // Then try persistent vulnerability cache
    const cachedVulnerabilities = await this.cacheManager.getCachedVulnerabilityData(projectPath);
    if (cachedVulnerabilities) {
      return this.createResultFromVulnerabilities(cachedVulnerabilities, 'cache');
    }

    return null;
  }
}
